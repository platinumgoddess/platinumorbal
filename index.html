<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Orb Fusion — Enhanced</title>
<style>
  :root {
    --bg: #0b0b0c;
    --panel: #111;
    --muted: #bdbdbd;
    --accent: #ffd166;
  }
  html, body { height: 100%; margin: 0; }
  body {
    background: linear-gradient(180deg, #070708, #121214);
    font-family: Inter, Segoe UI, system-ui, Arial, sans-serif;
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .wrap { width: 460px; max-width: 95%; text-align: center; }
  h1 { margin: 0 0 6px; font-size: 28px; color: var(--accent); }
  p.lead { margin: 0 0 16px; color: var(--muted); }
  .ui { display: flex; gap: 8px; justify-content: center; margin-bottom: 12px; }
  button {
    background: #1b1b1c; border: 0; color: #fff; padding: 10px 14px;
    border-radius: 8px; cursor: pointer; font-weight: 600;
  }
  button:hover { transform: translateY(-2px); }
  .info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
  .score { font-weight: 700; }
  .colorBox { width: 48px; height: 28px; border-radius: 6px; border: 2px solid rgba(255,255,255,0.08); }
  canvas {
    display: block; margin: 0 auto; background: radial-gradient(circle at 30% 20%, #262626, #0f0f10);
    border-radius: 10px; box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    touch-action: none;
  }
  .overlay { position: relative; }
  .msg {
    position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.6); padding: 18px 22px; border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.06);
  }
  .muted { color: var(--muted); font-size: 13px; }
  footer { margin-top: 10px; color: var(--muted); font-size: 13px; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Orb Fusion</h1>
  <p class="lead">Move with mouse/touch — click/tap to shoot. Avoid wrong colors, and don’t miss your own color.</p>

  <div class="ui">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="restartBtn">Restart</button>
  </div>

  <div class="info">
    <div class="score">Score: <span id="score">0</span></div>
    <div style="display:flex;align-items:center;gap:10px">
      <div class="muted">Current</div>
      <div id="curColor" class="colorBox"></div>
    </div>
  </div>

  <div class="overlay">
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <div id="message" class="msg" style="display:none"></div>
  </div>

  <footer class="muted">Tip: consecutive hits increase combo multiplier. Watch for special orbs!</footer>
</div>

<script>
const config = {
  orbR: 20,
  bulletR: 8,
  colors: ['#ef476f','#06d6a0','#118ab2','#ffd166','#9d4edd'],
  baseSpeed: 2,
  spawnRate: 40
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const curColorEl = document.getElementById('curColor');
const msgEl = document.getElementById('message');

let player, orbs, bullets, particles, score, running, gameOver, spawnTimer, rafId, combo, maxCombo;

function randInt(min,max){return Math.floor(Math.random()*(max-min+1))+min}
function choose(arr){return arr[randInt(0,arr.length-1)]}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy)}

function setMessage(html,show=true){
  msgEl.innerHTML = html;
  msgEl.style.display = show ? 'block' : 'none';
}
function clearMessage(){ setMessage('',false); }

function init(){
  player = {x: canvas.width/2, y: canvas.height - 60, color: choose(config.colors)};
  orbs = [];
  bullets = [];
  particles = [];
  score = 0;
  combo = 0;
  maxCombo = 0;
  running = false;
  gameOver = false;
  spawnTimer = 0;
  updateUI();
  clearMessage();
  drawOnce();
}

function updateUI(){
  scoreEl.textContent = score;
  curColorEl.style.background = player.color;
}

function start(){ if(running) return; running = true; gameOver = false; clearMessage(); lastTime=performance.now(); loop(lastTime); }
function stop(){ running = false; cancelAnimationFrame(rafId); }
function restart(){ init(); start(); }

document.getElementById('startBtn').addEventListener('click', start);
document.getElementById('stopBtn').addEventListener('click', ()=>{ running=false; setMessage('Paused — press Start to continue', true); });
document.getElementById('restartBtn').addEventListener('click', restart);
window.addEventListener('keydown', e=>{ if(e.code==='Space'){ if(gameOver) restart(); else shoot(); } });

// Mobile controls
canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  player.x = clamp(e.touches[0].clientX - r.left, config.orbR, canvas.width - config.orbR);
  updateUI();
}, {passive:false});
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); shoot(); });

canvas.addEventListener('mousemove', e=>{
  const r = canvas.getBoundingClientRect();
  player.x = clamp(e.clientX - r.left, config.orbR, canvas.width - config.orbR);
  updateUI();
});
canvas.addEventListener('click', shoot);

function shoot(){
  if(!running || gameOver) return;
  bullets.push({x: player.x, y: player.y - config.orbR - config.bulletR - 2, color: player.color, speed: 9});
  player.color = choose(config.colors);
  updateUI();
}

function spawnOrb(){
  const x = randInt(config.orbR, canvas.width - config.orbR);
  const typeChance = Math.random();
  let type = 'normal';
  if(typeChance < 0.05) type = 'rainbow';
  else if(typeChance < 0.1) type = 'bomb';
  const color = choose(config.colors);
  const speed = config.baseSpeed + Math.min(3, score/150) + Math.random()*1.2;
  orbs.push({x, y: -config.orbR, color, speed, type});
}

function spawnParticles(x,y,color){
  for(let i=0;i<6;i++){
    particles.push({x,y, color, dx:(Math.random()-0.5)*2, dy:(Math.random()-0.5)*2, life: 20});
  }
}

function step(dt){
  orbs.forEach(o=> o.y += o.speed * dt/16);
  bullets.forEach(b=> b.y -= b.speed * dt/16);
  bullets = bullets.filter(b => b.y > -20);

  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    for(let j=orbs.length-1;j>=0;j--){
      const o = orbs[j];
      if(dist(b,o) < config.orbR + config.bulletR - 2){
        if(o.type==='rainbow' || b.color===o.color){
          bullets.splice(i,1);
          orbs.splice(j,1);
          spawnParticles(o.x,o.y,o.color);
          score += 10 * (1 + combo*0.1);
          combo++; if(combo>maxCombo) maxCombo=combo;
          updateUI();
          break;
        } else {
          gameOver = true; setMessage(`<strong>Game Over</strong><br>Wrong color shot.<br>Score: ${score}<br>Max Combo: ${maxCombo}`); running = false; return;
        }
      }
    }
  }

  for(let i=orbs.length-1;i>=0;i--){
    const o = orbs[i];
    if(dist(player,o) < config.orbR*2 - 2){
      if(o.type==='rainbow'){ player.color = choose(config.colors); orbs.splice(i,1); updateUI(); continue; }
      if(o.type==='bomb'){ orbs=[]; bullets=[]; orbs.splice(i,1); spawnParticles(o.x,o.y,'#fff'); continue; }
      if(o.color===player.color){
        score += 5 * (1 + combo*0.1); combo++; if(combo>maxCombo) maxCombo=combo; orbs.splice(i,1); updateUI();
      } else { gameOver = true; setMessage(`<strong>Game Over</strong><br>Wrong orb touched.<br>Score: ${score}<br>Max Combo: ${maxCombo}`); running=false; return; }
    }
    if(o.y - config.orbR > player.y + 4){
      if(o.color===player.color){ gameOver = true; setMessage(`<strong>Game Over</strong><br>Missed your color.<br>Score: ${score}<br>Max Combo: ${maxCombo}`); running=false; return; }
      orbs.splice(i,1); combo=0;
    }
  }

  particles.forEach(p=>{p.x+=p.dx; p.y+=p.dy; p.life--;});
  particles = particles.filter(p=>p.life>0);

  spawnTimer++;
  const spawnThreshold = Math.max(18, config.spawnRate - Math.floor(Math.min(200, score)/6));
  if(spawnTimer > spawnThreshold){ spawnOrb(); spawnTimer=0; }
}

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(const o of orbs){ drawOrb(o.x,o.y,config.orbR,o.type==='rainbow'?'#fff':o.color,o.type!=='normal'); }
  for(const b of bullets){ drawOrb(b.x,b.y,config.bulletR,b.color); }
  drawOrb(player.x,player.y,config.orbR,player.color,true,combo);
  particles.forEach(p=>{
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life/20;
    ctx.beginPath(); ctx.arc(p.x,p.y,2,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  });
}

function drawOrb(x,y,r,color,glow=false,combo=0){
  ctx.save();
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fillStyle = color;
  if(glow){ ctx.shadowColor = color; ctx.shadowBlur = 10 + combo*2; }
  ctx.fill();
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.stroke();
  ctx.restore();
}

let lastTime=0;
function loop(timestamp){
  if(!running || gameOver) return;
  const dt = timestamp - lastTime; lastTime = timestamp;
  step(dt);
  render();
  rafId = requestAnimationFrame(loop);
}

function drawOnce(){ ctx.clearRect(0,0,canvas.width,canvas.height); drawOrb(player.x, player.y, config.orbR, player.color, true); }

init();
</script>
</body>
</html>
